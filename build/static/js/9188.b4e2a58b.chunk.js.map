{"version":3,"file":"static/js/9188.b4e2a58b.chunk.js","mappings":"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","sources":["../node_modules/@tsparticles/shape-image/browser/GifUtils/Constants.js","../node_modules/@tsparticles/shape-image/browser/GifUtils/ByteStream.js","../node_modules/@tsparticles/shape-image/browser/GifUtils/Utils.js"],"sourcesContent":["export const InterlaceOffsets = [0, 4, 2, 1];\nexport const InterlaceSteps = [8, 8, 4, 2];\n","export class ByteStream {\n    constructor(bytes) {\n        this.pos = 0;\n        this.data = new Uint8ClampedArray(bytes);\n    }\n    getString(count) {\n        const slice = this.data.slice(this.pos, this.pos + count);\n        this.pos += slice.length;\n        return slice.reduce((acc, curr) => acc + String.fromCharCode(curr), \"\");\n    }\n    nextByte() {\n        return this.data[this.pos++];\n    }\n    nextTwoBytes() {\n        const increment = 2, previous = 1, shift = 8;\n        this.pos += increment;\n        return this.data[this.pos - increment] + (this.data[this.pos - previous] << shift);\n    }\n    readSubBlocks() {\n        let blockString = \"\", size = 0;\n        const minCount = 0, emptySize = 0;\n        do {\n            size = this.data[this.pos++];\n            for (let count = size; --count >= minCount; blockString += String.fromCharCode(this.data[this.pos++])) {\n            }\n        } while (size !== emptySize);\n        return blockString;\n    }\n    readSubBlocksBin() {\n        let size = this.data[this.pos], len = 0;\n        const emptySize = 0, increment = 1;\n        for (let offset = 0; size !== emptySize; offset += size + increment, size = this.data[this.pos + offset]) {\n            len += size;\n        }\n        const blockData = new Uint8Array(len);\n        size = this.data[this.pos++];\n        for (let i = 0; size !== emptySize; size = this.data[this.pos++]) {\n            for (let count = size; --count >= emptySize; blockData[i++] = this.data[this.pos++]) {\n            }\n        }\n        return blockData;\n    }\n    skipSubBlocks() {\n        for (const increment = 1, noData = 0; this.data[this.pos] !== noData; this.pos += this.data[this.pos] + increment) {\n        }\n        this.pos++;\n    }\n}\n","import { InterlaceOffsets, InterlaceSteps } from \"./Constants.js\";\nimport { ByteStream } from \"./ByteStream.js\";\nconst origin = {\n    x: 0,\n    y: 0,\n}, defaultFrame = 0, half = 0.5, initialTime = 0, firstIndex = 0, defaultLoopCount = 0;\nfunction parseColorTable(byteStream, count) {\n    const colors = [];\n    for (let i = 0; i < count; i++) {\n        colors.push({\n            r: byteStream.data[byteStream.pos],\n            g: byteStream.data[byteStream.pos + 1],\n            b: byteStream.data[byteStream.pos + 2],\n        });\n        byteStream.pos += 3;\n    }\n    return colors;\n}\nfunction parseExtensionBlock(byteStream, gif, getFrameIndex, getTransparencyIndex) {\n    switch (byteStream.nextByte()) {\n        case 249: {\n            const frame = gif.frames[getFrameIndex(false)];\n            byteStream.pos++;\n            const packedByte = byteStream.nextByte();\n            frame.GCreserved = (packedByte & 0xe0) >>> 5;\n            frame.disposalMethod = (packedByte & 0x1c) >>> 2;\n            frame.userInputDelayFlag = (packedByte & 2) === 2;\n            const transparencyFlag = (packedByte & 1) === 1;\n            frame.delayTime = byteStream.nextTwoBytes() * 0xa;\n            const transparencyIndex = byteStream.nextByte();\n            if (transparencyFlag) {\n                getTransparencyIndex(transparencyIndex);\n            }\n            byteStream.pos++;\n            break;\n        }\n        case 255: {\n            byteStream.pos++;\n            const applicationExtension = {\n                identifier: byteStream.getString(8),\n                authenticationCode: byteStream.getString(3),\n                data: byteStream.readSubBlocksBin(),\n            };\n            gif.applicationExtensions.push(applicationExtension);\n            break;\n        }\n        case 254: {\n            gif.comments.push([getFrameIndex(false), byteStream.readSubBlocks()]);\n            break;\n        }\n        case 1: {\n            if (gif.globalColorTable.length === 0) {\n                throw new EvalError(\"plain text extension without global color table\");\n            }\n            byteStream.pos++;\n            gif.frames[getFrameIndex(false)].plainTextData = {\n                left: byteStream.nextTwoBytes(),\n                top: byteStream.nextTwoBytes(),\n                width: byteStream.nextTwoBytes(),\n                height: byteStream.nextTwoBytes(),\n                charSize: {\n                    width: byteStream.nextTwoBytes(),\n                    height: byteStream.nextTwoBytes(),\n                },\n                foregroundColor: byteStream.nextByte(),\n                backgroundColor: byteStream.nextByte(),\n                text: byteStream.readSubBlocks(),\n            };\n            break;\n        }\n        default:\n            byteStream.skipSubBlocks();\n            break;\n    }\n}\nasync function parseImageBlock(byteStream, gif, avgAlpha, getFrameIndex, getTransparencyIndex, progressCallback) {\n    const frame = gif.frames[getFrameIndex(true)];\n    frame.left = byteStream.nextTwoBytes();\n    frame.top = byteStream.nextTwoBytes();\n    frame.width = byteStream.nextTwoBytes();\n    frame.height = byteStream.nextTwoBytes();\n    const packedByte = byteStream.nextByte(), localColorTableFlag = (packedByte & 0x80) === 0x80, interlacedFlag = (packedByte & 0x40) === 0x40;\n    frame.sortFlag = (packedByte & 0x20) === 0x20;\n    frame.reserved = (packedByte & 0x18) >>> 3;\n    const localColorCount = 1 << ((packedByte & 7) + 1);\n    if (localColorTableFlag) {\n        frame.localColorTable = parseColorTable(byteStream, localColorCount);\n    }\n    const getColor = (index) => {\n        const { r, g, b } = (localColorTableFlag ? frame.localColorTable : gif.globalColorTable)[index];\n        if (index !== getTransparencyIndex(null)) {\n            return { r, g, b, a: 255 };\n        }\n        return { r, g, b, a: avgAlpha ? ~~((r + g + b) / 3) : 0 };\n    };\n    const image = (() => {\n        try {\n            return new ImageData(frame.width, frame.height, { colorSpace: \"srgb\" });\n        }\n        catch (error) {\n            if (error instanceof DOMException && error.name === \"IndexSizeError\") {\n                return null;\n            }\n            throw error;\n        }\n    })();\n    if (image == null) {\n        throw new EvalError(\"GIF frame size is to large\");\n    }\n    const minCodeSize = byteStream.nextByte(), imageData = byteStream.readSubBlocksBin(), clearCode = 1 << minCodeSize;\n    const readBits = (pos, len) => {\n        const bytePos = pos >>> 3, bitPos = pos & 7;\n        return (((imageData[bytePos] + (imageData[bytePos + 1] << 8) + (imageData[bytePos + 2] << 16)) &\n            (((1 << len) - 1) << bitPos)) >>>\n            bitPos);\n    };\n    if (interlacedFlag) {\n        for (let code = 0, size = minCodeSize + 1, pos = 0, dic = [[0]], pass = 0; pass < 4; pass++) {\n            if (InterlaceOffsets[pass] < frame.height) {\n                let pixelPos = 0, lineIndex = 0, exit = false;\n                while (!exit) {\n                    const last = code;\n                    code = readBits(pos, size);\n                    pos += size + 1;\n                    if (code === clearCode) {\n                        size = minCodeSize + 1;\n                        dic.length = clearCode + 2;\n                        for (let i = 0; i < dic.length; i++) {\n                            dic[i] = i < clearCode ? [i] : [];\n                        }\n                    }\n                    else {\n                        if (code >= dic.length) {\n                            dic.push(dic[last].concat(dic[last][0]));\n                        }\n                        else if (last !== clearCode) {\n                            dic.push(dic[last].concat(dic[code][0]));\n                        }\n                        for (const item of dic[code]) {\n                            const { r, g, b, a } = getColor(item);\n                            image.data.set([r, g, b, a], InterlaceOffsets[pass] * frame.width +\n                                InterlaceSteps[pass] * lineIndex +\n                                (pixelPos % (frame.width * 4)));\n                            pixelPos += 4;\n                        }\n                        if (dic.length === 1 << size && size < 0xc) {\n                            size++;\n                        }\n                    }\n                    if (pixelPos === frame.width * 4 * (lineIndex + 1)) {\n                        lineIndex++;\n                        if (InterlaceOffsets[pass] + InterlaceSteps[pass] * lineIndex >= frame.height) {\n                            exit = true;\n                        }\n                    }\n                }\n            }\n            progressCallback?.(byteStream.pos / (byteStream.data.length - 1), getFrameIndex(false) + 1, image, { x: frame.left, y: frame.top }, { width: gif.width, height: gif.height });\n        }\n        frame.image = image;\n        frame.bitmap = await createImageBitmap(image);\n    }\n    else {\n        let code = 0, size = minCodeSize + 1, pos = 0, pixelPos = -4, exit = false;\n        const dic = [[0]];\n        while (!exit) {\n            const last = code;\n            code = readBits(pos, size);\n            pos += size;\n            if (code === clearCode) {\n                size = minCodeSize + 1;\n                dic.length = clearCode + 2;\n                for (let i = 0; i < dic.length; i++) {\n                    dic[i] = i < clearCode ? [i] : [];\n                }\n            }\n            else {\n                if (code === clearCode + 1) {\n                    exit = true;\n                    break;\n                }\n                if (code >= dic.length) {\n                    dic.push(dic[last].concat(dic[last][0]));\n                }\n                else if (last !== clearCode) {\n                    dic.push(dic[last].concat(dic[code][0]));\n                }\n                for (const item of dic[code]) {\n                    const { r, g, b, a } = getColor(item);\n                    image.data.set([r, g, b, a], (pixelPos += 4));\n                }\n                if (dic.length >= 1 << size && size < 0xc) {\n                    size++;\n                }\n            }\n        }\n        frame.image = image;\n        frame.bitmap = await createImageBitmap(image);\n        progressCallback?.((byteStream.pos + 1) / byteStream.data.length, getFrameIndex(false) + 1, frame.image, { x: frame.left, y: frame.top }, { width: gif.width, height: gif.height });\n    }\n}\nasync function parseBlock(byteStream, gif, avgAlpha, getFrameIndex, getTransparencyIndex, progressCallback) {\n    switch (byteStream.nextByte()) {\n        case 59:\n            return true;\n        case 44:\n            await parseImageBlock(byteStream, gif, avgAlpha, getFrameIndex, getTransparencyIndex, progressCallback);\n            break;\n        case 33:\n            parseExtensionBlock(byteStream, gif, getFrameIndex, getTransparencyIndex);\n            break;\n        default:\n            throw new EvalError(\"undefined block found\");\n    }\n    return false;\n}\nexport function getGIFLoopAmount(gif) {\n    for (const extension of gif.applicationExtensions) {\n        if (extension.identifier + extension.authenticationCode !== \"NETSCAPE2.0\") {\n            continue;\n        }\n        return extension.data[1] + (extension.data[2] << 8);\n    }\n    return NaN;\n}\nexport async function decodeGIF(gifURL, progressCallback, avgAlpha) {\n    if (!avgAlpha)\n        avgAlpha = false;\n    const res = await fetch(gifURL);\n    if (!res.ok && res.status === 404) {\n        throw new EvalError(\"file not found\");\n    }\n    const buffer = await res.arrayBuffer();\n    const gif = {\n        width: 0,\n        height: 0,\n        totalTime: 0,\n        colorRes: 0,\n        pixelAspectRatio: 0,\n        frames: [],\n        sortFlag: false,\n        globalColorTable: [],\n        backgroundImage: new ImageData(1, 1, { colorSpace: \"srgb\" }),\n        comments: [],\n        applicationExtensions: [],\n    }, byteStream = new ByteStream(new Uint8ClampedArray(buffer));\n    if (byteStream.getString(6) !== \"GIF89a\") {\n        throw new Error(\"not a supported GIF file\");\n    }\n    gif.width = byteStream.nextTwoBytes();\n    gif.height = byteStream.nextTwoBytes();\n    const packedByte = byteStream.nextByte(), globalColorTableFlag = (packedByte & 0x80) === 0x80;\n    gif.colorRes = (packedByte & 0x70) >>> 4;\n    gif.sortFlag = (packedByte & 8) === 8;\n    const globalColorCount = 1 << ((packedByte & 7) + 1), backgroundColorIndex = byteStream.nextByte();\n    gif.pixelAspectRatio = byteStream.nextByte();\n    if (gif.pixelAspectRatio !== 0) {\n        gif.pixelAspectRatio = (gif.pixelAspectRatio + 0xf) / 0x40;\n    }\n    if (globalColorTableFlag) {\n        gif.globalColorTable = parseColorTable(byteStream, globalColorCount);\n    }\n    const backgroundImage = (() => {\n        try {\n            return new ImageData(gif.width, gif.height, { colorSpace: \"srgb\" });\n        }\n        catch (error) {\n            if (error instanceof DOMException && error.name === \"IndexSizeError\") {\n                return null;\n            }\n            throw error;\n        }\n    })();\n    if (backgroundImage == null) {\n        throw new Error(\"GIF frame size is to large\");\n    }\n    const { r, g, b } = gif.globalColorTable[backgroundColorIndex];\n    backgroundImage.data.set(globalColorTableFlag ? [r, g, b, 255] : [0, 0, 0, 0]);\n    for (let i = 4; i < backgroundImage.data.length; i *= 2) {\n        backgroundImage.data.copyWithin(i, 0, i);\n    }\n    gif.backgroundImage = backgroundImage;\n    let frameIndex = -1, incrementFrameIndex = true, transparencyIndex = -1;\n    const getframeIndex = (increment) => {\n        if (increment) {\n            incrementFrameIndex = true;\n        }\n        return frameIndex;\n    };\n    const getTransparencyIndex = (newValue) => {\n        if (newValue != null) {\n            transparencyIndex = newValue;\n        }\n        return transparencyIndex;\n    };\n    try {\n        do {\n            if (incrementFrameIndex) {\n                gif.frames.push({\n                    left: 0,\n                    top: 0,\n                    width: 0,\n                    height: 0,\n                    disposalMethod: 0,\n                    image: new ImageData(1, 1, { colorSpace: \"srgb\" }),\n                    plainTextData: null,\n                    userInputDelayFlag: false,\n                    delayTime: 0,\n                    sortFlag: false,\n                    localColorTable: [],\n                    reserved: 0,\n                    GCreserved: 0,\n                });\n                frameIndex++;\n                transparencyIndex = -1;\n                incrementFrameIndex = false;\n            }\n        } while (!(await parseBlock(byteStream, gif, avgAlpha, getframeIndex, getTransparencyIndex, progressCallback)));\n        gif.frames.length--;\n        for (const frame of gif.frames) {\n            if (frame.userInputDelayFlag && frame.delayTime === 0) {\n                gif.totalTime = Infinity;\n                break;\n            }\n            gif.totalTime += frame.delayTime;\n        }\n        return gif;\n    }\n    catch (error) {\n        if (error instanceof EvalError) {\n            throw new Error(`error while parsing frame ${frameIndex} \"${error.message}\"`);\n        }\n        throw error;\n    }\n}\nexport function drawGif(data) {\n    const { context, radius, particle, delta } = data, image = particle.image;\n    if (!image?.gifData || !image.gif) {\n        return;\n    }\n    const offscreenCanvas = new OffscreenCanvas(image.gifData.width, image.gifData.height), offscreenContext = offscreenCanvas.getContext(\"2d\");\n    if (!offscreenContext) {\n        throw new Error(\"could not create offscreen canvas context\");\n    }\n    offscreenContext.imageSmoothingQuality = \"low\";\n    offscreenContext.imageSmoothingEnabled = false;\n    offscreenContext.clearRect(origin.x, origin.y, offscreenCanvas.width, offscreenCanvas.height);\n    if (particle.gifLoopCount === undefined) {\n        particle.gifLoopCount = image.gifLoopCount ?? defaultLoopCount;\n    }\n    let frameIndex = particle.gifFrame ?? defaultFrame;\n    const pos = { x: -image.gifData.width * half, y: -image.gifData.height * half }, frame = image.gifData.frames[frameIndex];\n    if (particle.gifTime === undefined) {\n        particle.gifTime = initialTime;\n    }\n    if (!frame.bitmap) {\n        return;\n    }\n    context.scale(radius / image.gifData.width, radius / image.gifData.height);\n    switch (frame.disposalMethod) {\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 0:\n            offscreenContext.drawImage(frame.bitmap, frame.left, frame.top);\n            context.drawImage(offscreenCanvas, pos.x, pos.y);\n            offscreenContext.clearRect(origin.x, origin.y, offscreenCanvas.width, offscreenCanvas.height);\n            break;\n        case 1:\n            offscreenContext.drawImage(frame.bitmap, frame.left, frame.top);\n            context.drawImage(offscreenCanvas, pos.x, pos.y);\n            break;\n        case 2:\n            offscreenContext.drawImage(frame.bitmap, frame.left, frame.top);\n            context.drawImage(offscreenCanvas, pos.x, pos.y);\n            offscreenContext.clearRect(origin.x, origin.y, offscreenCanvas.width, offscreenCanvas.height);\n            if (!image.gifData.globalColorTable.length) {\n                offscreenContext.putImageData(image.gifData.frames[firstIndex].image, pos.x + frame.left, pos.y + frame.top);\n            }\n            else {\n                offscreenContext.putImageData(image.gifData.backgroundImage, pos.x, pos.y);\n            }\n            break;\n        case 3:\n            {\n                const previousImageData = offscreenContext.getImageData(origin.x, origin.y, offscreenCanvas.width, offscreenCanvas.height);\n                offscreenContext.drawImage(frame.bitmap, frame.left, frame.top);\n                context.drawImage(offscreenCanvas, pos.x, pos.y);\n                offscreenContext.clearRect(origin.x, origin.y, offscreenCanvas.width, offscreenCanvas.height);\n                offscreenContext.putImageData(previousImageData, origin.x, origin.y);\n            }\n            break;\n    }\n    particle.gifTime += delta.value;\n    if (particle.gifTime > frame.delayTime) {\n        particle.gifTime -= frame.delayTime;\n        if (++frameIndex >= image.gifData.frames.length) {\n            if (--particle.gifLoopCount <= defaultLoopCount) {\n                return;\n            }\n            frameIndex = firstIndex;\n            offscreenContext.clearRect(origin.x, origin.y, offscreenCanvas.width, offscreenCanvas.height);\n        }\n        particle.gifFrame = frameIndex;\n    }\n    context.scale(image.gifData.width / radius, image.gifData.height / radius);\n}\nexport async function loadGifImage(image) {\n    if (image.type !== \"gif\") {\n        const { loadImage } = await import(\"../Utils.js\");\n        await loadImage(image);\n        return;\n    }\n    image.loading = true;\n    try {\n        image.gifData = await decodeGIF(image.source);\n        image.gifLoopCount = getGIFLoopAmount(image.gifData) ?? defaultLoopCount;\n        if (!image.gifLoopCount) {\n            image.gifLoopCount = Infinity;\n        }\n    }\n    catch {\n        image.error = true;\n    }\n    image.loading = false;\n}\n"],"names":["InterlaceOffsets","InterlaceSteps","ByteStream","bytes","_classCallCheck","this","pos","data","Uint8ClampedArray","_createClass","key","value","count","slice","length","reduce","acc","curr","String","fromCharCode","blockString","size","len","offset","blockData","Uint8Array","i","origin","x","y","defaultFrame","half","initialTime","firstIndex","defaultLoopCount","parseColorTable","byteStream","colors","push","r","g","b","parseExtensionBlock","gif","getFrameIndex","getTransparencyIndex","nextByte","frame","frames","packedByte","GCreserved","disposalMethod","userInputDelayFlag","transparencyFlag","delayTime","nextTwoBytes","transparencyIndex","applicationExtension","identifier","getString","authenticationCode","readSubBlocksBin","applicationExtensions","comments","readSubBlocks","globalColorTable","EvalError","plainTextData","left","top","width","height","charSize","foregroundColor","backgroundColor","text","skipSubBlocks","parseImageBlock","_x","_x2","_x3","_x4","_x5","_x6","_parseImageBlock","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","avgAlpha","progressCallback","localColorTableFlag","interlacedFlag","localColorCount","getColor","image","minCodeSize","imageData","clearCode","readBits","code","dic","pass","pixelPos","lineIndex","exit","last","_iterator2","_step2","item","_getColor","a","_code","_size","_pos","_pixelPos","_exit","_dic","_last","_i","_iterator3","_step3","_item","_getColor2","_r","_g","_b","_a","wrap","_context","prev","next","sortFlag","reserved","localColorTable","index","_index","ImageData","colorSpace","error","DOMException","name","bytePos","bitPos","concat","_createForOfIteratorHelper","s","n","done","set","err","e","f","createImageBitmap","bitmap","sent","abrupt","stop","parseBlock","_x7","_x8","_x9","_x10","_x11","_x12","_parseBlock","_callee2","_context2","t0","getGIFLoopAmount","_step","_iterator","extension","NaN","decodeGIF","_x13","_x14","_x15","_decodeGIF","_callee3","gifURL","res","buffer","globalColorTableFlag","globalColorCount","backgroundColorIndex","backgroundImage","_gif$globalColorTable","frameIndex","incrementFrameIndex","getframeIndex","_iterator4","_step4","_frame","_context3","fetch","ok","status","arrayBuffer","totalTime","colorRes","pixelAspectRatio","Error","copyWithin","increment","newValue","Infinity","finish","t1","message","drawGif","_particle$gifFrame","context","radius","particle","delta","gifData","_image$gifLoopCount","offscreenCanvas","OffscreenCanvas","offscreenContext","getContext","imageSmoothingQuality","imageSmoothingEnabled","clearRect","undefined","gifLoopCount","gifFrame","gifTime","scale","drawImage","putImageData","previousImageData","getImageData","loadGifImage","_x16","_loadGifImage","_callee4","_yield$import","loadImage","_getGIFLoopAmount","_context4","type","loading","source"],"sourceRoot":""}