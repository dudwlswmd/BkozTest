{"version":3,"file":"static/js/6844.f8592a95.chunk.js","mappings":"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","sources":["../node_modules/@tsparticles/updater-out-modes/browser/BounceOutMode.js","../node_modules/@tsparticles/updater-out-modes/browser/Utils.js","../node_modules/@tsparticles/updater-out-modes/browser/DestroyOutMode.js","../node_modules/@tsparticles/updater-out-modes/browser/NoneOutMode.js","../node_modules/@tsparticles/updater-out-modes/browser/OutOutMode.js","../node_modules/@tsparticles/updater-out-modes/browser/OutOfCanvasUpdater.js"],"sourcesContent":["import { calculateBounds, } from \"@tsparticles/engine\";\nimport { bounceHorizontal, bounceVertical } from \"./Utils.js\";\nexport class BounceOutMode {\n    constructor(container) {\n        this.container = container;\n        this.modes = [\n            \"bounce\",\n            \"split\",\n        ];\n    }\n    update(particle, direction, delta, outMode) {\n        if (!this.modes.includes(outMode)) {\n            return;\n        }\n        const container = this.container;\n        let handled = false;\n        for (const [, plugin] of container.plugins) {\n            if (plugin.particleBounce !== undefined) {\n                handled = plugin.particleBounce(particle, delta, direction);\n            }\n            if (handled) {\n                break;\n            }\n        }\n        if (handled) {\n            return;\n        }\n        const pos = particle.getPosition(), offset = particle.offset, size = particle.getRadius(), bounds = calculateBounds(pos, size), canvasSize = container.canvas.size;\n        bounceHorizontal({ particle, outMode, direction, bounds, canvasSize, offset, size });\n        bounceVertical({ particle, outMode, direction, bounds, canvasSize, offset, size });\n    }\n}\n","import { getRangeValue } from \"@tsparticles/engine\";\nconst minVelocity = 0, boundsMin = 0;\nexport function bounceHorizontal(data) {\n    if ((data.outMode !== \"bounce\" && data.outMode !== \"split\") ||\n        (data.direction !== \"left\" && data.direction !== \"right\")) {\n        return;\n    }\n    if (data.bounds.right < boundsMin && data.direction === \"left\") {\n        data.particle.position.x = data.size + data.offset.x;\n    }\n    else if (data.bounds.left > data.canvasSize.width && data.direction === \"right\") {\n        data.particle.position.x = data.canvasSize.width - data.size - data.offset.x;\n    }\n    const velocity = data.particle.velocity.x;\n    let bounced = false;\n    if ((data.direction === \"right\" &&\n        data.bounds.right >= data.canvasSize.width &&\n        velocity > minVelocity) ||\n        (data.direction === \"left\" && data.bounds.left <= boundsMin && velocity < minVelocity)) {\n        const newVelocity = getRangeValue(data.particle.options.bounce.horizontal.value);\n        data.particle.velocity.x *= -newVelocity;\n        bounced = true;\n    }\n    if (!bounced) {\n        return;\n    }\n    const minPos = data.offset.x + data.size;\n    if (data.bounds.right >= data.canvasSize.width && data.direction === \"right\") {\n        data.particle.position.x = data.canvasSize.width - minPos;\n    }\n    else if (data.bounds.left <= boundsMin && data.direction === \"left\") {\n        data.particle.position.x = minPos;\n    }\n    if (data.outMode === \"split\") {\n        data.particle.destroy();\n    }\n}\nexport function bounceVertical(data) {\n    if ((data.outMode !== \"bounce\" && data.outMode !== \"split\") ||\n        (data.direction !== \"bottom\" && data.direction !== \"top\")) {\n        return;\n    }\n    if (data.bounds.bottom < boundsMin && data.direction === \"top\") {\n        data.particle.position.y = data.size + data.offset.y;\n    }\n    else if (data.bounds.top > data.canvasSize.height && data.direction === \"bottom\") {\n        data.particle.position.y = data.canvasSize.height - data.size - data.offset.y;\n    }\n    const velocity = data.particle.velocity.y;\n    let bounced = false;\n    if ((data.direction === \"bottom\" &&\n        data.bounds.bottom >= data.canvasSize.height &&\n        velocity > minVelocity) ||\n        (data.direction === \"top\" && data.bounds.top <= boundsMin && velocity < minVelocity)) {\n        const newVelocity = getRangeValue(data.particle.options.bounce.vertical.value);\n        data.particle.velocity.y *= -newVelocity;\n        bounced = true;\n    }\n    if (!bounced) {\n        return;\n    }\n    const minPos = data.offset.y + data.size;\n    if (data.bounds.bottom >= data.canvasSize.height && data.direction === \"bottom\") {\n        data.particle.position.y = data.canvasSize.height - minPos;\n    }\n    else if (data.bounds.top <= boundsMin && data.direction === \"top\") {\n        data.particle.position.y = minPos;\n    }\n    if (data.outMode === \"split\") {\n        data.particle.destroy();\n    }\n}\n","import { Vector, getDistances, isPointInside, } from \"@tsparticles/engine\";\nconst minVelocity = 0;\nexport class DestroyOutMode {\n    constructor(container) {\n        this.container = container;\n        this.modes = [\"destroy\"];\n    }\n    update(particle, direction, _delta, outMode) {\n        if (!this.modes.includes(outMode)) {\n            return;\n        }\n        const container = this.container;\n        switch (particle.outType) {\n            case \"normal\":\n            case \"outside\":\n                if (isPointInside(particle.position, container.canvas.size, Vector.origin, particle.getRadius(), direction)) {\n                    return;\n                }\n                break;\n            case \"inside\": {\n                const { dx, dy } = getDistances(particle.position, particle.moveCenter), { x: vx, y: vy } = particle.velocity;\n                if ((vx < minVelocity && dx > particle.moveCenter.radius) ||\n                    (vy < minVelocity && dy > particle.moveCenter.radius) ||\n                    (vx >= minVelocity && dx < -particle.moveCenter.radius) ||\n                    (vy >= minVelocity && dy < -particle.moveCenter.radius)) {\n                    return;\n                }\n                break;\n            }\n        }\n        container.particles.remove(particle, undefined, true);\n    }\n}\n","import { Vector, isPointInside, } from \"@tsparticles/engine\";\nconst minVelocity = 0;\nexport class NoneOutMode {\n    constructor(container) {\n        this.container = container;\n        this.modes = [\"none\"];\n    }\n    update(particle, direction, delta, outMode) {\n        if (!this.modes.includes(outMode)) {\n            return;\n        }\n        if ((particle.options.move.distance.horizontal &&\n            (direction === \"left\" || direction === \"right\")) ??\n            (particle.options.move.distance.vertical &&\n                (direction === \"top\" || direction === \"bottom\"))) {\n            return;\n        }\n        const gravityOptions = particle.options.move.gravity, container = this.container, canvasSize = container.canvas.size, pRadius = particle.getRadius();\n        if (!gravityOptions.enable) {\n            if ((particle.velocity.y > minVelocity && particle.position.y <= canvasSize.height + pRadius) ||\n                (particle.velocity.y < minVelocity && particle.position.y >= -pRadius) ||\n                (particle.velocity.x > minVelocity && particle.position.x <= canvasSize.width + pRadius) ||\n                (particle.velocity.x < minVelocity && particle.position.x >= -pRadius)) {\n                return;\n            }\n            if (!isPointInside(particle.position, container.canvas.size, Vector.origin, pRadius, direction)) {\n                container.particles.remove(particle);\n            }\n        }\n        else {\n            const position = particle.position;\n            if ((!gravityOptions.inverse &&\n                position.y > canvasSize.height + pRadius &&\n                direction === \"bottom\") ||\n                (gravityOptions.inverse && position.y < -pRadius && direction === \"top\")) {\n                container.particles.remove(particle);\n            }\n        }\n    }\n}\n","import { Vector, calculateBounds, getDistances, getRandom, isPointInside, randomInRange, } from \"@tsparticles/engine\";\nconst minVelocity = 0, minDistance = 0;\nexport class OutOutMode {\n    constructor(container) {\n        this.container = container;\n        this.modes = [\"out\"];\n    }\n    update(particle, direction, delta, outMode) {\n        if (!this.modes.includes(outMode)) {\n            return;\n        }\n        const container = this.container;\n        switch (particle.outType) {\n            case \"inside\": {\n                const { x: vx, y: vy } = particle.velocity;\n                const circVec = Vector.origin;\n                circVec.length = particle.moveCenter.radius;\n                circVec.angle = particle.velocity.angle + Math.PI;\n                circVec.addTo(Vector.create(particle.moveCenter));\n                const { dx, dy } = getDistances(particle.position, circVec);\n                if ((vx <= minVelocity && dx >= minDistance) ||\n                    (vy <= minVelocity && dy >= minDistance) ||\n                    (vx >= minVelocity && dx <= minDistance) ||\n                    (vy >= minVelocity && dy <= minDistance)) {\n                    return;\n                }\n                particle.position.x = Math.floor(randomInRange({\n                    min: 0,\n                    max: container.canvas.size.width,\n                }));\n                particle.position.y = Math.floor(randomInRange({\n                    min: 0,\n                    max: container.canvas.size.height,\n                }));\n                const { dx: newDx, dy: newDy } = getDistances(particle.position, particle.moveCenter);\n                particle.direction = Math.atan2(-newDy, -newDx);\n                particle.velocity.angle = particle.direction;\n                break;\n            }\n            default: {\n                if (isPointInside(particle.position, container.canvas.size, Vector.origin, particle.getRadius(), direction)) {\n                    return;\n                }\n                switch (particle.outType) {\n                    case \"outside\": {\n                        particle.position.x =\n                            Math.floor(randomInRange({\n                                min: -particle.moveCenter.radius,\n                                max: particle.moveCenter.radius,\n                            })) + particle.moveCenter.x;\n                        particle.position.y =\n                            Math.floor(randomInRange({\n                                min: -particle.moveCenter.radius,\n                                max: particle.moveCenter.radius,\n                            })) + particle.moveCenter.y;\n                        const { dx, dy } = getDistances(particle.position, particle.moveCenter);\n                        if (particle.moveCenter.radius) {\n                            particle.direction = Math.atan2(dy, dx);\n                            particle.velocity.angle = particle.direction;\n                        }\n                        break;\n                    }\n                    case \"normal\": {\n                        const warp = particle.options.move.warp, canvasSize = container.canvas.size, newPos = {\n                            bottom: canvasSize.height + particle.getRadius() + particle.offset.y,\n                            left: -particle.getRadius() - particle.offset.x,\n                            right: canvasSize.width + particle.getRadius() + particle.offset.x,\n                            top: -particle.getRadius() - particle.offset.y,\n                        }, sizeValue = particle.getRadius(), nextBounds = calculateBounds(particle.position, sizeValue);\n                        if (direction === \"right\" &&\n                            nextBounds.left > canvasSize.width + particle.offset.x) {\n                            particle.position.x = newPos.left;\n                            particle.initialPosition.x = particle.position.x;\n                            if (!warp) {\n                                particle.position.y = getRandom() * canvasSize.height;\n                                particle.initialPosition.y = particle.position.y;\n                            }\n                        }\n                        else if (direction === \"left\" && nextBounds.right < -particle.offset.x) {\n                            particle.position.x = newPos.right;\n                            particle.initialPosition.x = particle.position.x;\n                            if (!warp) {\n                                particle.position.y = getRandom() * canvasSize.height;\n                                particle.initialPosition.y = particle.position.y;\n                            }\n                        }\n                        if (direction === \"bottom\" &&\n                            nextBounds.top > canvasSize.height + particle.offset.y) {\n                            if (!warp) {\n                                particle.position.x = getRandom() * canvasSize.width;\n                                particle.initialPosition.x = particle.position.x;\n                            }\n                            particle.position.y = newPos.top;\n                            particle.initialPosition.y = particle.position.y;\n                        }\n                        else if (direction === \"top\" && nextBounds.bottom < -particle.offset.y) {\n                            if (!warp) {\n                                particle.position.x = getRandom() * canvasSize.width;\n                                particle.initialPosition.x = particle.position.x;\n                            }\n                            particle.position.y = newPos.bottom;\n                            particle.initialPosition.y = particle.position.y;\n                        }\n                        break;\n                    }\n                }\n                break;\n            }\n        }\n    }\n}\n","import { BounceOutMode } from \"./BounceOutMode.js\";\nimport { DestroyOutMode } from \"./DestroyOutMode.js\";\nimport { NoneOutMode } from \"./NoneOutMode.js\";\nimport { OutOutMode } from \"./OutOutMode.js\";\nconst checkOutMode = (outModes, outMode) => {\n    return (outModes.default === outMode ||\n        outModes.bottom === outMode ||\n        outModes.left === outMode ||\n        outModes.right === outMode ||\n        outModes.top === outMode);\n};\nexport class OutOfCanvasUpdater {\n    constructor(container) {\n        this._updateOutMode = (particle, delta, outMode, direction) => {\n            for (const updater of this.updaters) {\n                updater.update(particle, direction, delta, outMode);\n            }\n        };\n        this.container = container;\n        this.updaters = [];\n    }\n    init(particle) {\n        this.updaters = [];\n        const outModes = particle.options.move.outModes;\n        if (checkOutMode(outModes, \"bounce\")) {\n            this.updaters.push(new BounceOutMode(this.container));\n        }\n        else if (checkOutMode(outModes, \"out\")) {\n            this.updaters.push(new OutOutMode(this.container));\n        }\n        else if (checkOutMode(outModes, \"destroy\")) {\n            this.updaters.push(new DestroyOutMode(this.container));\n        }\n        else if (checkOutMode(outModes, \"none\")) {\n            this.updaters.push(new NoneOutMode(this.container));\n        }\n    }\n    isEnabled(particle) {\n        return !particle.destroyed && !particle.spawning;\n    }\n    update(particle, delta) {\n        const outModes = particle.options.move.outModes;\n        this._updateOutMode(particle, delta, outModes.bottom ?? outModes.default, \"bottom\");\n        this._updateOutMode(particle, delta, outModes.left ?? outModes.default, \"left\");\n        this._updateOutMode(particle, delta, outModes.right ?? outModes.default, \"right\");\n        this._updateOutMode(particle, delta, outModes.top ?? outModes.default, \"top\");\n    }\n}\n"],"names":["BounceOutMode","container","_classCallCheck","this","modes","_createClass","key","value","particle","direction","delta","outMode","includes","_step","handled","_iterator","_createForOfIteratorHelper","plugins","s","n","done","plugin","_slicedToArray","undefined","particleBounce","err","e","f","pos","getPosition","offset","size","getRadius","bounds","calculateBounds","canvasSize","canvas","data","right","position","x","left","width","velocity","bounced","newVelocity","getRangeValue","options","bounce","horizontal","minPos","destroy","bounceHorizontal","bottom","y","top","height","vertical","bounceVertical","DestroyOutMode","_delta","outType","isPointInside","Vector","origin","_getDistances","getDistances","moveCenter","dx","dy","_particle$velocity","vx","vy","radius","particles","remove","NoneOutMode","_ref","move","distance","gravityOptions","gravity","pRadius","enable","inverse","OutOutMode","circVec","length","angle","Math","PI","addTo","create","floor","randomInRange","min","max","_getDistances2","newDx","newDy","atan2","_getDistances3","warp","newPos","sizeValue","nextBounds","initialPosition","getRandom","checkOutMode","outModes","default","OutOfCanvasUpdater","_this","_updateOutMode","updaters","update","push","destroyed","spawning","_outModes$bottom","_outModes$left","_outModes$right","_outModes$top"],"sourceRoot":""}